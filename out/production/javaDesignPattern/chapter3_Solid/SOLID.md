**단일 책임의 원칙**
- 단하나만의 책임을 가져야 한다.

책임의 의미
객체지향 설계 관점에서는 SRP에서 말하는 책임의 기본 단위는 객체를 지칭한다.
즉 객체는 단 하나의 책임만을 가져야 한다는 것

책임 = 해야하는 것 .
책임 = 할 수 있는 것.
책임 = 해야 하는 것을 잘 할 수 있는 것.

EX)

public class Student {
 public void getCourses(){}
 public void addCourse(course c){}
  public void save(){}
   public Student load(){}
    
}

그러나 이대로는 학생 클래스가 너무 많은 책임을 수행한다.
student 클래스에는 수강과목을 조회하고 추가하는 기능을 수행하도록 하는 것이
SRP를 따르는 설계다.




3.1.2변경

SRP에 따르는 실효성 있는 설계가 되려면 책임을 좀 더 현실적인 개념으로 파악할 수 있다.
우리가 설계 원칙을 학습하는 이유는 예측하지 못한 변경사항이 발생하더라도 유연하고 
확장성이 있도록 시스템 구조를 설계하기 위함이다.

클래스가 잘 설계되어있는지 판단하려면 언제 변경되어야 하는지를
물어보는 것이 좋다.

책임 = 변경이유.

__Student 클래스는 언제 변경되어야 하는 가?__ 

-데이터베이스의 스키마가 변경된다면 Student클래스도 변경되어야 하는가?

-학생이 지도 교수를 찾는 기능이 추가되어야 한다면 Student 클래스는 영향을 받는가?

-학생 정보를 성적표와 출석부 이외의 형식으로 출력해야 한다면 어떻게 해야하는가?

이러한 사항은 모두 학생 클래스를 변경해야하는 이유가 된다.

책임을 많이 질 수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게
결합될 가능성이 높아진다. 


3.1.3 책임 분리
Student 클래스는 여러 책임을 수행하므로 Student 클래스의 도움을 필요로 하는 코드도 많을 수 밖에 없다.
학생의 수강과목 목록을 사용해 어떤일을 수행하는 코드도 Student의 도움을 필요로하며
신입생 정보를 데이터베이스에 기록하는 데도 Student 클래스를  필요로 할수있다. 
또한 성정표와 출석부를 필요로 하는 코드도 Student 클래스를 사용할 수 있다.

이러한 이유 때문에 학생 클래스에 변경사항이 생기면 Student 클래스를 사용하는
코드와 전혀 관계가 없더라도 직접 또는 간접적으로 사용하는 모든 코드를 다시 
테스트 해야 한다.

학생 클래스의 경우 변경될 사유가 될 수 있는 것은 학생의 고유정보, 
데이터베이스 스키마 , 출력 형식의 변화 등 3가지다. 
따라서 학생 클래스는 학생 고유의 역할을 수행하게 끔 변경하고 학생 클래스의
인스턴스를 데이터베이스에 저장하거나 읽어들이는 역할을 담당ㅈ하는 학생DAO클래스와
출석부와 성적표에 출력을 담당하는 성적표 클래스와 출석부 클래스로 분리하는
편이 좋다.

책임을 적절하게 분담하도록 하ㅏ면 어떤 변화가 생겼을 때 영향을 최소화 할 수 있다.

3.1.4 산탄총 수술

하나의 책임이 여러개의 클래스들로 분산되어 있는 경우에도 단일 책임 원칙에 입각해
설계를 변경해야 하는 경우도 있다.

이때 산탄총 수술이라는 용어를 사용한다.
클래스 하나하나를 모두 변경하지 않으면 프로그램이 정상적으로 동작하지 않고
에러가 발생한다. 하나의 책임이 여러개의 클래스로 분리되어 있는 예는 
특히 로깅, 보안 , 트랜잭션과 같은 횡단 관심으로 분류할 수 있는 기능이 대표적이다.


3.2 개방-폐쇄 원칙

개방-폐쇄 원칙은 어려운 말처럼 들릴지 모르겠지만 의미는 매우 명확하다.
기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다는
뜻이다.

OCP를 보드는 또하나의 관점은 클래스르 변경하지 않고도 대상클래스의 환경을
변경할 수 있는 설계가 되어야 한다는 것이다. 
이는 특히 단위 테스트를 수행할 때 매우 중요하다.

3.3 리스코프 치환 원칙

LSP는 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 한다는 뜻
LSP를 이해하려면 일반화 관계를 다시 생각해볼 필요가 있다.
일반화 관계는 IS A KIND OF 관계라고도 한다.

원숭이는 -> 포유류다.
고래는 -> 포유류다.
사람은 -> 포유류다.

포유류는 알을 낳지 않는다.
포유류는 젖을 먹여 새끼를 키우고 폐를 통해 호흡한다.

사람,고래 , 원숭이에 대입해보면 IS A KIND OF 일반화 관계를 확인 할 수 있다.

오리너구리--> 포유류다.X 
오리너구리는 위에 해당하지 않는다. 즉 
LSP에 해당하지 않는다. 


3. 4 의존 역전 원칙


객체 사이에 서로 도움을 주고 받으면 의존 관계가 발생한다.
의존 역전 원칙은 그러한 의존 관계를 맺을 때의 가이드라인에 해당한다.

DIP는 의존관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것 
변화가 없는 것에 의존하라는 원칙이다.

DEPENDENCY INVERSION PRINCIPLE 

그렇다면 변화하기 쉬운것과 변화하기 어려운 것은 어떻게 구분할까?
큰 흐름이나 개념 같은 추상적인 것은 변화하기 어려운 것
구체적인 방식 사물과같은 것은 변화하기 쉬운 것으로 구분한다.

아이 ---->       ABSTRACT 장난감
          /             l           |
       로봇          모형자동차          레고
 
 
로봇, 모형 자동차, 레고 는 변하기 쉬운 것 
아이--> 장난감 은 변화기 어려운 것


인터페이스 == 변화지 않는 것,
구체 클래스 == 변하기 쉬운 것 

만약 
아이 클래스가 ----> 로봇 클래스를 직접 의존할 경우 
다른 장난감을 추가해야 할 때 수정해야 할 부분이 많아 짐 짜증남 ㅋㅋ죽음 

DIP원칙 위반이 OCP 원칙 위반으로 이어진다.

3.5 인터페이스 분리원칙

인터페이스 분리 원칙 ISP는 객체지향 설계원칙에는 클라이언트 자신이 사용하지 않는 기능에는
영향을 받지 않아야 한다는 내용이 담겨 있음 

복사기 예제

                              복사 클라이언트
                                    ㅣ
                                    ㅣ
       프린터 클라이언트  -------- 복합기 ------------------팩스 클라이언트
                                 copy();
                                 fax();
                                 print();
                                 
복합기능을 제공하는 클래스는 매우 비대해질 가능성이 크다. 
하지만 이 비대한 클래스의 모든 기능을 클라이언트가 동시에 사용하는 경우는 거의 없다. 
클라이언트의 필요에 따라. 프린터만 사용한다든지 팩스 기능만 이용하든지 복사기 기능만 이용할 수 있다.
따라서 프린터 기능을 이용하는 클라이언트가 팩스 기능의 변경으로 인해 발생하는 문제의 영향을 받지 않도록 해야한다.

클라이언트와 무관하게 발생하는 변화로 클라이언트 자신이 영향을 받지 않으려면 범용의 인터페이스보다는 클라이언트에 특화된 인터페이스를
이용해야 한다.

즉 ISP Interface Segregation Principle 는 인터페이스를 클라이언트에 특화되도록 분리시키는 설계원칙이다.


복사기 클래스에 isp 원칙을 적용한 결과


    프린터 클라이언트                                       복사클라이언트
    
           ㅣ                                                   ㅣ
           ㅣ                                                   ㅣ
         interface                                         interface
         프린터                                               복사기
         print()                                            copy()
         
             l------------------복합기  ----------------------ㅣ
                               copy()
                               fax()
                               print()
                           
                                 l
                               interface
                               팩스
                               fax()
                               
                                 l
                           팩스 클라이언트
                           
                           